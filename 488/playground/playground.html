<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Хэкиль и Лайд</title>
        <style>
            :root {
                --size: 16px;
            }

            body {
                margin: 0;
            }

            .container {
                display: flex;
                justify-content: center;
                align-items: center;

                height: 100vh;
                width: 100vw;
            }

            .field {
                box-sizing: border-box;
                border: 1px solid black;

                position: relative;

                height: calc(var(--size) * 38);
                width: calc(var(--size) * 41);
            }

            .pixel {
                box-sizing: border-box;
                border: 1px solid black;

                position: absolute;

                top: calc(var(--size) * var(--row));
                left: calc(var(--size) * var(--col));

                height: var(--size);
                width: var(--size);
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="field" class="field"></div>
        </div>
        <script src="./constants.js"></script>
        <script src="./sdk.js"></script>
        <script>
            const spamArt = async () => {
                const delay = (ms) => new Promise((res) => setTimeout(res, ms));
                const width = art[0].length;

                const posStart = 10;
                const pixels = document.querySelectorAll(".pixel");

                for (let pos = posStart; pos < posStart + 15; pos++) {
                    const pixel = pixels[pos * width + pos];

                    await delay(500);

                    pixel.style.setProperty("background-color", "#0077ff");
                }

                const posColStart = 27; //21
                const posRowStart = 19; //13
                for (let posRow = posRowStart; posRow < posRowStart + 5; posRow++) {
                    for (let posCol = posColStart; posCol < posColStart + 5; posCol++) {
                        const pixel = pixels[posRow * width + posCol];

                        pixel.style.setProperty("background-color", "#0077ff");
                    }
                }
            };

            const maxChangePixelColorCalls = 16; //15
            const maxChangeAreaColorCalls = 4; //1

            const sdk = new SDK(art);

            const field = document.getElementById("field");
            sdk.initArt(field);

            const observeArt = (field, art, colors) => {
                // your code here...
                const config = {
                    subtree: true,
                    attributeOldValue: true
                };

                const currentBlotch = [];

                class Repainter {
                    _ptrBlotch = 0;
                    _blotchs = [];
                    _field;
                    _art;
                    _colors;

                    constructor(field, art, colors) {
                        this._field = field;
                        this._art = art;
                        this._colors = colors;
                        this.rSize = art.length;
                        this.cSize = art[0].length;
                        this._badArt = Array(this.rSize)
                            .fill()
                            .map(() => Array(this.cSize).fill(0));
                    }

                    rectRepaint() {
                        let count = 0;
                        while (this.lastBlotch().getArea() > 0) {
                            const rect = this.lastBlotch().maxPartTest();
                            for (let i = rect.top; i <= rect.bottom; i++) {
                                for (let j = rect.left; j <= rect.right; j++) {
                                    this._badArt[i][j] = 2;
                                }
                            }
                            // if (rect.area > 1) {
                            //     sdk.changeAreaColor(
                            //         rect.left,
                            //         rect.top,
                            //         rect.right,
                            //         rect.bottom,
                            //         this._colors[rect.color]
                            //     );
                            //     // console.log("area", rect);
                            // } else {
                            //     sdk.changePixelColor(rect.left, rect.top, this._colors[rect.color]);
                            //     // console.log("point", rect);
                            // }
                            count++;
                        }

                        this.lastBlotch().nestingRect();
                        console.log(count);
                    }

                    _getProperty(el) {
                        const style = getComputedStyle(el);
                        return { col: +style.getPropertyValue("--col"), row: +style.getPropertyValue("--row") };
                    }

                    addPixel(el) {
                        const { col, row } = this._getProperty(el);
                        if (this._badArt[row][col] === 0) {
                            if (!this.lastBlotch() || !this.lastBlotch().isNeighbor(col, row)) {
                                this.addBlotch();
                            }

                            this.lastBlotch().addPixel(col, row);
                            this._badArt[row][col] = 1;
                        }
                    }

                    addBlotch() {
                        if (this.lastBlotch()) {
                            this.rectRepaint();
                        }
                        const blotch = new Blotch(this._art, this._badArt);
                        this._blotchs.push(blotch);
                        return blotch;
                    }

                    lastBlotch() {
                        return this._blotchs.length > 0 ? this._blotchs[this._blotchs.length - 1] : undefined;
                    }
                }

                class Blotch {
                    _rect = {};
                    _smearyColors = new Map();
                    _art;
                    _badArt;
                    _area;

                    constructor(art, badArt) {
                        this._area = 0;
                        this._art = art;
                        this._badArt = badArt;
                    }

                    _recalcRect(col, row) {
                        this._rect.left = this._rect.left ? Math.min(this._rect.left, col) : col;
                        this._rect.right = this._rect.right ? Math.max(this._rect.right, col) : col;
                        this._rect.top = this._rect.top ? Math.min(this._rect.top, row) : row;
                        this._rect.bottom = this._rect.bottom ? Math.max(this._rect.bottom, row) : row;
                    }

                    _checkColor(col, row) {
                        const color = this._art[row][col];

                        if (!this._smearyColors.has(color)) {
                            this._smearyColors.set(color, { pixels: [] });
                        }
                        this._smearyColors.get(color).pixels.push({ col, row });
                    }

                    _getCountPixel(top, left, bottom, right, colorCode) {
                        let iTop = top - this._rect.top + 1;
                        let jLeft = left - this._rect.left + 1;
                        let iBottom = bottom - this._rect.bottom + 1;
                        let jRight = right - this._rect.right + 1;

                        return (
                            this._smearyColors.get(colorCode).prefix[iBottom][jRight] -
                            this._smearyColors.get(colorCode).prefix[iTop - 1][jRight] -
                            this._smearyColors.get(colorCode).prefix[iBottom][jLeft - 1] +
                            this._smearyColors.get(colorCode).prefix[iTop - 1][jLeft - 1]
                        );
                    }

                    getArea() {
                        return this._area;
                    }

                    maxPartTest() {
                        const R = this._rect.bottom - this._rect.top + 1;
                        const C = this._rect.right - this._rect.left + 1;
                        const dp = {};

                        const maxArea = {};
                        const maxRect = {};
                        for (let color of this._smearyColors.keys()) {
                            dp[color] = Array(R)
                                .fill()
                                .map(() => Array(C).fill(0));
                            maxArea[color] = 0;
                        }

                        for (let i = 0; i < R; i++) {
                            for (let j = 0; j < C; j++) {
                                if (this._badArt[this._rect.top + i][this._rect.left + j] === 1) {
                                    const currentColor = this._art[this._rect.top + i][this._rect.left + j];

                                    dp[currentColor][i][j] = j === 0 ? 1 : dp[currentColor][i][j - 1] + 1;
                                    let width = dp[currentColor][i][j];
                                    let areaRect;
                                    let minHeight = i;
                                    for (
                                        let k = i;
                                        k >= 0 && this._art[this._rect.top + k][this._rect.left + j] === currentColor;
                                        k--
                                    ) {
                                        if (width <= dp[currentColor][k][j]) {
                                            width = dp[currentColor][k][j];
                                            minHeight = k;
                                        }

                                        areaRect = width * (i - k + 1);

                                        if (areaRect > maxArea[currentColor]) {
                                            maxArea[currentColor] = areaRect;
                                            maxRect[currentColor] = {
                                                top: this._rect.top + minHeight,
                                                left: this._rect.left + j - width + 1,
                                                bottom: this._rect.top + i,
                                                right: this._rect.left + j,
                                                area: width * (i - minHeight + 1)
                                            };
                                        }
                                    }
                                }
                            }
                        }
                        let resultRect = { area: 0 };

                        for (let color in maxRect) {
                            if (resultRect.area < maxRect[color].area) {
                                resultRect = maxRect[color];
                                resultRect.color = color;
                            }
                        }
                        this._area -= resultRect.area;
                        return resultRect;
                    }

                    _getNextRect(fromTop, fromLeft, height, width, color) {
                        let resizeable = true;

                        for (let i = fromTop; i < fromTop + height && resizeable; i++) {
                            if (art[i][fromLeft + width] !== color) {
                                resizeable = false;
                            }
                        }
                        if (resizeable) {
                            _getNextRect(fromTop, fromLeft, height, width + 1);
                        }

                        resizeable = true;

                        for (let j = fromLeft; j < fromLeft + width && resizeable; j++) {
                            if (art[fromTop + height][j] !== color) {
                                resizeable = false;
                            }
                        }
                        if (resizeable) {
                            _getNextRect(fromTop, fromLeft, height + 1, width);
                        }
                    }

                    nestingRect(maxCountRect) {
                        this.maxCountRect = maxCountRect;

                        const colorCodes = [...this._smearyColors.keys()];

                        for (let colorCode of colorCodes) {
                            this._smearyColors.get(colorCode)["prefix"] = [];
                            // this._smearyColors.get(colorCode).prefix.push([]);
                        }

                        for (let i = this._rect.top - 1; i <= this._rect.bottom; i++) {
                            let iPrefix = i - this._rect.top + 1;

                            for (let colorCode of colorCodes) {
                                this._smearyColors.get(colorCode).prefix[iPrefix] = [];
                            }

                            for (let j = this._rect.left - 1; j <= this._rect.right; j++) {
                                let jPrefix = j - this._rect.left + 1;

                                for (let colorCode of this._smearyColors.keys()) {
                                    if (iPrefix !== 0 && jPrefix !== 0) {
                                        this._smearyColors.get(colorCode).prefix[iPrefix][jPrefix] =
                                            this._smearyColors.get(colorCode).prefix[iPrefix - 1][jPrefix] +
                                            this._smearyColors.get(colorCode).prefix[iPrefix][jPrefix - 1] -
                                            this._smearyColors.get(colorCode).prefix[iPrefix - 1][jPrefix - 1] +
                                            (this._art[i][j] === colorCode ? 1 : 0);
                                    } else {
                                        this._smearyColors.get(colorCode).prefix[iPrefix][jPrefix] = 0;
                                    }
                                }
                            }
                        }
                        console.log(this._smearyColors);

                        // this._getNextRect(i, j, 1, 1, color);
                    }

                    addPixel(col, row) {
                        this._area++;
                        this._recalcRect(col, row);
                        this._checkColor(col, row);
                    }

                    isNeighbor(col, row) {
                        return (
                            (this._rect.left <= col &&
                                this._rect.right >= col &&
                                this._rect.top - 1 <= row &&
                                this._rect.bottom + 1 >= row) ||
                            (this._rect.left - 1 <= col &&
                                this._rect.right + 1 >= col &&
                                this._rect.top <= row &&
                                this._rect.bottom >= row)
                        );
                    }
                }

                const colorRepainter = new Repainter(field, art, colors);
                let handlerTimeout;

                const callback = (mutationList) => {
                    for (const mutation of mutationList) {
                        if (mutation.type === "attributes") {
                            colorRepainter.addPixel(mutation.target);
                            if (handlerTimeout) {
                                clearTimeout(handlerTimeout);
                            }

                            handlerTimeout = setTimeout(() => {
                                colorRepainter.rectRepaint();
                            }, 2000);
                        }
                    }
                };

                const observer = new MutationObserver(callback);
                observer.observe(field, config);
            };

            observeArt(field, art, colors);

            spamArt();
        </script>
    </body>
</html>
