<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Хэкиль и Лайд</title>
        <style>
            :root {
                --size: 16px;
            }

            body {
                margin: 0;
            }

            .container {
                display: flex;
                justify-content: center;
                align-items: center;

                height: 100vh;
                width: 100vw;
            }

            .field {
                box-sizing: border-box;
                border: 1px solid black;

                position: relative;

                height: calc(var(--size) * 38);
                width: calc(var(--size) * 41);
            }

            .pixel {
                box-sizing: border-box;
                border: 1px solid black;

                position: absolute;

                top: calc(var(--size) * var(--row));
                left: calc(var(--size) * var(--col));

                height: var(--size);
                width: var(--size);
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="field" class="field"></div>
        </div>
        <script src="./constants.js"></script>
        <script src="./sdk.js"></script>
        <script>
            const spamArt = async () => {
                const delay = (ms) => new Promise((res) => setTimeout(res, ms));
                const width = art[0].length;

                const posStart = 10;
                const pixels = document.querySelectorAll(".pixel");

                for (let pos = posStart; pos < posStart + 15; pos++) {
                    const pixel = pixels[pos * width + pos];

                    await delay(500);

                    pixel.style.setProperty("background-color", "#0077ff");
                }

                const posColStart = 27; //21
                const posRowStart = 18; //13
                for (let posRow = posRowStart; posRow < posRowStart + 3; posRow++) {
                    for (let posCol = posColStart; posCol < posColStart + 3; posCol++) {
                        const pixel = pixels[posRow * width + posCol];

                        pixel.style.setProperty("background-color", "#0077ff");
                    }
                }
            };

            const maxChangePixelColorCalls = 20; //15
            const maxChangeAreaColorCalls = 10; //1

            const sdk = new SDK(art);

            const field = document.getElementById("field");
            sdk.initArt(field);

            const observeArt = (field, art, colors) => {
                // your code here...
                const config = {
                    subtree: true,
                    attributeOldValue: true
                };

                const currentBlotch = [];

                class Repainter {
                    #isEndAttack = false;
                    #pixels = [];

                    #handlerTimeout = [];
                    #ptrHandler = 0;

                    #blotchs = [];

                    #art;
                    #colors;

                    constructor(art, colors) {
                        this.#art = art;
                        this.#colors = colors;
                    }

                    savePixel(el) {
                        const { col, row } = this.#getProperty(el);

                        if (!this.#isEndAttack) {
                            this.#pixels.push({ col, row });

                            while (this.#ptrHandler < this.#handlerTimeout.length) {
                                clearTimeout(this.#handlerTimeout[this.#ptrHandler]);
                                this.#handlerTimeout[this.#ptrHandler] = null;
                                this.#ptrHandler++;
                            }

                            this.#handlerTimeout.push(
                                setTimeout(
                                    (thisRepainter) => {
                                        thisRepainter.#endAttack();
                                    },
                                    2000,
                                    this
                                )
                            );
                        }
                    }

                    #getProperty(el) {
                        const style = getComputedStyle(el);
                        return { col: +style.getPropertyValue("--col"), row: +style.getPropertyValue("--row") };
                    }

                    #rectRepaint(blotch) {
                        let optimalResult = blotch.nestingRect();

                        for (let rect of optimalResult) {
                            if (rect.area > 1) {
                                sdk.changeAreaColor(
                                    rect.left,
                                    rect.top,
                                    rect.right,
                                    rect.bottom,
                                    this.#colors[rect.color]
                                );
                            } else {
                                sdk.changePixelColor(rect.left, rect.top, this.#colors[rect.color]);
                            }
                        }
                    }

                    #groupPixelToBlotchs({ col, row }) {
                        let isAdded = false;

                        for (let blotch of this.#blotchs) {
                            if (blotch.isNeighbor({ col, row })) {
                                isAdded = true;
                                blotch.addPixel({ col, row });
                            }
                        }

                        if (!isAdded) {
                            this.#addBlotch();
                            this.#blotchs[this.#blotchs.length - 1].addPixel({ col, row });
                        }
                    }

                    #endAttack() {
                        this.#isEndAttack = true;
                        this.#pixels.sort((a, b) => a.row - b.row || a.col - b.col);

                        this.#pixels.forEach((p) => this.#groupPixelToBlotchs(p));
                        this.#blotchs.forEach((b) => this.#rectRepaint(b));
                    }

                    #addBlotch() {
                        const blotch = new Blotch(this.#art);
                        this.#blotchs.push(blotch);
                        return blotch;
                    }
                }

                class Blotch {
                    #art;
                    #rect = {};
                    #smearyColors = new Map();
                    #minimalCountRect = Infinity;
                    #optimalResult = [];
                    #optimalWeight = 0;

                    #stateVisited = [];
                    #stateStack = [];

                    constructor(art) {
                        this.#art = art;
                    }

                    addPixel({ col, row }) {
                        this.#rect.left = this.#rect.left ? Math.min(this.#rect.left, col) : col;
                        this.#rect.right = this.#rect.right ? Math.max(this.#rect.right, col) : col;
                        this.#rect.top = this.#rect.top ? Math.min(this.#rect.top, row) : row;
                        this.#rect.bottom = this.#rect.bottom ? Math.max(this.#rect.bottom, row) : row;

                        const color = this.#getColor({ col, row });

                        if (!this.#smearyColors.has(color)) {
                            this.#smearyColors.set(color, { pixels: [] });
                        }
                        this.#smearyColors.get(color).pixels.push({ col, row });
                    }

                    nestingRect() {
                        const colorCodes = [...this.#smearyColors.keys()];

                        for (let colorCode of colorCodes) {
                            this.#smearyColors.get(colorCode)["prefix"] = [];
                        }

                        for (let i = this.#rect.top - 1; i <= this.#rect.bottom; i++) {
                            let iPrefix = i - this.#rect.top + 1;

                            for (let colorCode of colorCodes) {
                                this.#smearyColors.get(colorCode).prefix[iPrefix] = [];
                            }

                            if (i > 0) this.#stateVisited.push([]);

                            for (let j = this.#rect.left - 1; j <= this.#rect.right; j++) {
                                let jPrefix = j - this.#rect.left + 1;

                                for (let colorCode of this.#smearyColors.keys()) {
                                    if (iPrefix !== 0 && jPrefix !== 0) {
                                        this.#smearyColors.get(colorCode).prefix[iPrefix][jPrefix] =
                                            this.#smearyColors.get(colorCode).prefix[iPrefix - 1][jPrefix] +
                                            this.#smearyColors.get(colorCode).prefix[iPrefix][jPrefix - 1] -
                                            this.#smearyColors.get(colorCode).prefix[iPrefix - 1][jPrefix - 1] +
                                            (this.#getColor({ row: i, col: j }) === colorCode ? 1 : 0);
                                    } else {
                                        this.#smearyColors.get(colorCode).prefix[iPrefix][jPrefix] = 0;
                                    }
                                }
                            }
                        }
                        this.#nextRect();

                        return this.#optimalResult;
                    }

                    isNeighbor({ col, row }) {
                        return (
                            (this.#rect.left <= col &&
                                this.#rect.right >= col &&
                                this.#rect.top - 1 <= row &&
                                this.#rect.bottom + 1 >= row) ||
                            (this.#rect.left - 1 <= col &&
                                this.#rect.right + 1 >= col &&
                                this.#rect.top <= row &&
                                this.#rect.bottom >= row)
                        );
                    }

                    #getColor({ col, row }) {
                        return this.#art[row][col];
                    }

                    #countPixelByColor(top, left, bottom, right, colorCode) {
                        return (
                            this.#smearyColors.get(colorCode).prefix[bottom][right] -
                            this.#smearyColors.get(colorCode).prefix[top - 1][right] -
                            this.#smearyColors.get(colorCode).prefix[bottom][left - 1] +
                            this.#smearyColors.get(colorCode).prefix[top - 1][left - 1]
                        );
                    }

                    #markVizitedRect(top, left, bottom, right, marker) {
                        for (let i = top; i < bottom; i++) {
                            for (let j = left; j < right; j++) {
                                this.#stateVisited[i][j] = marker;
                            }
                        }
                    }

                    #nextRect() {
                        const countRectFinded = this.#stateStack.length;

                        let existNoVisited = false;
                        let fromTop;
                        let fromLeft;

                        for (let i = this.#rect.top; i <= this.#rect.bottom && !existNoVisited; i++) {
                            for (let j = this.#rect.left; j <= this.#rect.right && !existNoVisited; j++) {
                                if (!this.#stateVisited[i - this.#rect.top][j - this.#rect.left]) {
                                    existNoVisited = true;
                                    fromTop = i;
                                    fromLeft = j;
                                }
                            }
                        }

                        if (!existNoVisited || this.#minimalCountRect <= countRectFinded) {
                            if (!existNoVisited && this.#minimalCountRect >= countRectFinded) {
                                const newWeight = this.#stateStack.reduce((weight, rect) => weight * rect.area, 1);

                                /**
                                 * Задача принимается платформой как с максимизацией,
                                 * так и с минимизацией кол-ва площадных групп пикселей
                                 * относительно одиночных.
                                 *
                                 * this.#optimalWeight < newWeight - максимизирует
                                 * this.#optimalWeight > newWeight - минимизирует
                                 *
                                 * Соответственно, инициализация:
                                 * #optimalWeight = 0;
                                 * #optimalWeight = Infinity;
                                 */

                                if (
                                    (this.#minimalCountRect === countRectFinded && this.#optimalWeight < newWeight) ||
                                    this.#minimalCountRect > countRectFinded
                                ) {
                                    this.#optimalResult = Array.from(this.#stateStack);
                                    this.#minimalCountRect = countRectFinded;
                                    this.#optimalWeight = newWeight;
                                }
                            }
                            return;
                        }

                        let iPrefix = fromTop - this.#rect.top + 1;
                        let jPrefix = fromLeft - this.#rect.left + 1;

                        const currentColor = this.#getColor({ row: fromTop, col: fromLeft });

                        for (let i = fromTop; i <= this.#rect.bottom; i++) {
                            let height = i - fromTop + 1;

                            for (let j = fromLeft; j <= this.#rect.right; j++) {
                                let width = j - fromLeft + 1;

                                if (
                                    !this.#stateVisited[iPrefix + height - 2][jPrefix + width - 2] &&
                                    this.#countPixelByColor(
                                        iPrefix,
                                        jPrefix,
                                        iPrefix + height - 1,
                                        jPrefix + width - 1,
                                        currentColor
                                    ) ===
                                        height * width
                                ) {
                                    this.#markVizitedRect(
                                        iPrefix - 1,
                                        jPrefix - 1,
                                        iPrefix + height - 1,
                                        jPrefix + width - 1,
                                        true
                                    );

                                    this.#stateStack.push({
                                        top: fromTop,
                                        left: fromLeft,
                                        bottom: i,
                                        right: j,
                                        area: height * width,
                                        color: currentColor
                                    });

                                    this.#nextRect();

                                    this.#stateStack.pop();

                                    this.#markVizitedRect(
                                        iPrefix - 1,
                                        jPrefix - 1,
                                        iPrefix + height - 1,
                                        jPrefix + width - 1,
                                        false
                                    );
                                }
                            }
                        }
                    }
                }

                const colorRepainter = new Repainter(art, colors);

                const callback = (mutationList) => {
                    for (const mutation of mutationList) {
                        if (mutation.type === "attributes") {
                            colorRepainter.savePixel(mutation.target);
                        }
                    }
                };

                const observer = new MutationObserver(callback);
                observer.observe(field, config);
            };

            observeArt(field, art, colors);

            spamArt();
        </script>
    </body>
</html>
